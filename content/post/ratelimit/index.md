---
title: "微服务治理算法之限流"
date: 2021-09-12T16:55:40+08:00
tags: ["Golang", "Algorithm", "Distributed System"]
image: 
draft: true
---

## 背景

在微服务系统治理策略中，限流是其中非常重要的一种手段。这里先区分一个概念，在一次远程过程调用（RPC）中，发起调用的一方我们可以成为客户端（Client），而响应请求的一方我们称之为服务端（Server），所以对于一个服务实例来说，它既可以以Client的角色出现去调用其他服务，也可以以Server的角色来处理其他服务的请求。

限流的主要目的还是为了防止服务间突发的大量请求导致超过服务端的处理能力上限，这些请求会大量的占用服务的CPU及内存等资源，使得服务总体的处理能力下降，甚至导致服务最终不可用。有时候大量的请求可能是来自于正常的用户访问，比如突发的热点事件，或者商品秒杀活动等，都会导致短时间内产生大量请求，在服务处理能力受限的情况下，我们只能选择通过限流来牺牲一部分请求的质量（返回请求失败），来尽可能的保证服务的正常运行。当然也存在恶意请求攻击导致请求数量激增，以上都是服务提供方无法控制的行为，在资源有限的条件下，限流便是一种必备的服务保护手段。

我们常说的限流主要是在服务端侧对请求的数量进行限制（客户端可以通过熔断策略来控制流量），超出限制的请求一般会被**直接拒绝**，即请求失败，当然也可以有以下处理方式：

* 延迟处理：放入一些队列结构进行缓冲，等待服务端进行延迟处理。
* 服务降级：通过对一些重要程度较低的服务进行降级处理，提供更多的资源优先保证重要服务处理更多的请求
* 服务扩容：通过如Kubernetes HPA等方式，让服务启动更多实例来响应请求
* 特权请求：优先保证响应重要用户的请求

不过对于业务场景不复杂且资源有限的场景，直接拒绝是最简单有效的处理方式。



## 传统限流算法

### 计数器

计数器算法有固定窗口与滑动窗口两种计数策略：



### 漏桶



### 令牌桶



### 传统算法总结

- 固定窗口计数算法简单易实现，其缺陷是可能在中间的某一秒内通过的请求数是限流阈值的两倍，该算法仅适用于对限流准确度要求不高的应用场景。
- 滑动窗口计数算法解决了固定窗口计数算法的缺陷，但是该算法较难实现，因为要记录每次请求所以可能出现比较占用内存比较多的情况。
- 漏桶算法可以做到均匀平滑的限制请求，Ngixn 热 limit_req 模块也是采用此种算法。因为匀速处理请求的缘故所以该算法应对限流阈值内的突发请求无法及时处理。
- 令牌桶算法解决了以上三个算法的所有缺陷，是一种相对比较完美的限流算法，也是限流场景中应用最为广泛的算法



## 自适应限流算法

### 何为自适应



### 设计与实现



### 局限性

