<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on かがやの部屋</title>
    <link>https://example.com/tags/database/</link>
    <description>Recent content in Database on かがやの部屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 07 Apr 2019 21:30:20 +0800</lastBuildDate><atom:link href="https://example.com/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQL变量总结</title>
      <link>https://example.com/p/2019/sql%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 07 Apr 2019 21:30:20 +0800</pubDate>
      
      <guid>https://example.com/p/2019/sql%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</guid>
      <description>SQL变量总结 变量分类  用户变量  以@开始，形式为@变量名 全局变量  set global 变量名 或者 set @@global.变量名 对所有客户端生效 只有具有super权限才可以设置全局变量   会话变量  用户变量与mysql客户端绑定，只对当前用户使用的客户端生效 只对连接的客户端生效     局部变量  declare专门用于声明 作用范围在begin和end语句块之间    定义方法  &amp;ldquo;=&amp;quot;,如 set @a =3,@a:=5 &amp;ldquo;:=&amp;quot;。select常常这样使用 set可以使用以上两种形式设置变量。而select只能使用&amp;rdquo;:=&amp;ldquo;的形式设置变量 未定义的变量初始化是null  示例题目： X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。
请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。
   id visit_date people     1 2017-01-01 10   2 2017-01-02 109   3 2017-01-03 150   4 2017-01-04 99   5 2017-01-05 145   6 2017-01-06 1455   7 2017-01-07 199   8 2017-01-08 188    对于上面实例数据，应当输出</description>
    </item>
    
    <item>
      <title>Mysql和MariaDB中的Rank排序的坑</title>
      <link>https://example.com/p/2019/mysql%E5%92%8Cmariadb%E4%B8%AD%E7%9A%84rank%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Mon, 01 Apr 2019 21:30:20 +0800</pubDate>
      
      <guid>https://example.com/p/2019/mysql%E5%92%8Cmariadb%E4%B8%AD%E7%9A%84rank%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91/</guid>
      <description>Mysql和MariaDB中的Rank排序的坑 题目中需要对一个成绩表按考试科目以及学生做排名
为了加快之后其他步骤的查询速度，我想着将所有成绩都添加好排名后建立一个临时表
想法是
 先将score表中按考试课程升序，考试成绩降序，学号后两位升序做子查询 在新表中调用自定义的rank函数添加排名  rank函数是这样写的：
/* 临时rank function 要求原表按id score_mark降序 排列好 */delimiter//dropfunctionifexistsmyrank;createfunctionmyrank(score_idint,score_markfloat)returnsintREADSSQLDATAbeginif(@pre_score_idisnullor@pre_score_id!=score_id)thenset@pre_score_id:=score_id;set@pre_score_mark:=score_mark;set@row:=1;set@rank:=1;elseset@row:=@row+1;if(@pre_score_mark!=score_markorscore_markisnull)thenset@rank:=@row;set@pre_score_mark=score_mark;endif;endif;return@rank;end//delimiter;完整的临时表建立过程如下，看起来结构很简单，只是对已经排好序的表统计排名：
droptableifexiststmp_table_rank;createtabletmp_table_rankasselectscore_id,score_stuno,Score_mark,myrank(score_id,Score_mark)asrankfrom(select*fromscoreorderbyscore_idasc,Score_markdesc,right(score_stuno,2)asc);写完后在个人的云服务器上测试了一下结果符合预期，但为了保险起见，又在虚拟机上测试了同样数据和同样的代码，结果却不一样！！！
？？？
首先怀疑的是mysql版本的问题
服务器上使用的mysql版本为mysql Ver 14.14 Distrib 5.6.37, for linux-glibc2.12 (x86_64) using EditLine wrapper
虚拟机上则是mysql Ver 15.1 5.5.56-mariaDB
按理说mariaDB本质上还是mysql，结果却不一样。。。
在询问同学和老师后怀疑是两者在排序和调用函数的处理上有不同，理论上期望mysql先做完子查询的排序后，对排好序的表计算rank，mysql确实是这么做的，但是mariaDB似乎还没做完子查询的排序就开始调用函数计算rank，导致每个人的成绩和排名对应不上，出现错误
针对这个怀疑，做出了如下修改：
先将子查询放入一个临时表中，再调用该临时表
/* 临时table, 按科目添加排名 */droptableifexiststmp_table_asc;createtabletmp_table_ascasselect*fromscoreorderbyscore_idasc,Score_markdesc,right(score_stuno,2)asc;droptableifexiststmp_table_rank;createtabletmp_table_rankasselectscore_id,score_stuno,Score_mark,myrank(score_id,Score_mark)asrankfromtmp_table_asc;结果正确了，果然你俩还不是一个东西啊（苦笑</description>
    </item>
    
  </channel>
</rss>
