<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on かがやの部屋</title>
    <link>https://kagaya85.github.io/post/</link>
    <description>Recent content in Posts on かがやの部屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 23 Sep 2020 16:47:28 +0800</lastBuildDate><atom:link href="https://kagaya85.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Docker部署本地Wordpress开发环境</title>
      <link>https://kagaya85.github.io/2020/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0wordpress%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 23 Sep 2020 16:47:28 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2020/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0wordpress%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>使用Docker部署本地Wordpress开发环境 为了便于维护开发线上的wordpress站点，在本地构建一个wordpress开发环境。使用Docker来实现轻量化开发与部署环境的构建。
背景 由于最近接手了一个网站的运维工作，使用的还是Wordpress，因为有涉及到一些布局的调整，因此决定在本地构建一个开发调试环境用于进行上线前的测试，但又不想离开本机中Vscode等开发环境（如代码提示等）。在考虑了包括虚拟机LANMP，本机直接构建环境等方案后，最后选择了Docker来部署开发环境，同时也可以进一步熟悉Docker的使用方法。有了Docker，免去了虚拟机中繁杂的环境配置过程，同时对环境进行模块化解耦后可以十分便捷的启动或更新开发环境组件，也使得开发环境尽可能的贴近生产环境，之后的部署上线将变得十分容易。
本机环境 MacOS 10.15.6（理论上适用于所有支持Docker的环境）
Docker Desktop 19.03.12
镜像准备 $ docker images nginx latest 7e4d58f0e5f3 12 days ago 133MB mysql 5.7.31 ef08065b0a30 13 days ago 448MB daocloud.io/library/php 7.2.24-fpm 48432d192e1a 11 months ago 398MB 由于使用了Wordpress，所以环境的搭建涉及到了三个部分，ngin、mysql以及php，为了与生产环境一致，特别选择了对应的mysql与php的版本。理论上也不建议选择latest版本的镜像，选择相对稳定的版本会有更好的兼容性。
可以从docker hub上搜索对应版本的镜像
拉取镜像 $ docker pull nginx:latest $ docker pull mysql:5.7.31 $ docker pull daocloud.io/library/php:7.2.24-fpm 构建Nginx+PHP环境 Nginx配置 Nginx的镜像是不能解析php文件的，因此我们需要为nginx配置php-fpm来负责解析处理php代码并返回处理结果。
为此，我们需要做一下几件事情：
 修改nginx的配置，指定php处理方式 通过设置使nginx能够访问到php容器 启动nginx与php的容器  首先，为了持久化配置，我在/Users/kagaya/Docker/nginx/conf.d/下新建了default.conf配置文件，挂载到目标文件/etc/nginx/conf.d:ro并指定只读属性
最后对nginx的配置文件做对应修改即可：
# default.conf server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.</description>
    </item>
    
    <item>
      <title>八佰，好。管虎，待定</title>
      <link>https://kagaya85.github.io/2020/%E5%85%AB%E4%BD%B0%E5%A5%BD%E7%AE%A1%E8%99%8E%E5%BE%85%E5%AE%9A/</link>
      <pubDate>Mon, 17 Aug 2020 22:42:52 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2020/%E5%85%AB%E4%BD%B0%E5%A5%BD%E7%AE%A1%E8%99%8E%E5%BE%85%E5%AE%9A/</guid>
      <description>八佰，好。管虎，待定。 我先给《八佰》一个好评 《八佰》看完了，还专门去看了IMAX版。尽管这部电影从宣发到撤档再到重新定档上映，之间备受争议。但我还说要说，仅从抗战电影本身来说，这是部好电影，甚至超出了我之前看过的所有抗战片，我要给它很高的评价。《八佰》的出现对于中国抗战片来说有一定的特殊意义，类似《流浪地球》对于中国科幻片。这不仅因为它是一部少有的大陆拍摄的国军战役，而且制作团队对于电影的取材，伴奏配乐，画面分镜以及叙事节奏的掌握都十分出色。最后所表达的主题也很明确：**尽管这是一场必然失败的“表演”战役，但是“八佰壮士”用自己的行动向江对岸的人展示了中国军人真正的气魄，以此来唤醒更多中国人参与抗战。**这点我深表赞同。
个人认为唯一的争议 说说争议点，对我来说唯一让我非常不满的是导演管虎本人，《八佰》是部好电影，但是宣发的时候特意要去找八十八师师长“飞将军”孙元良的后人，孙的行为在抗战期间颇有争议，尽管是孙元良当时亲自给谢晋元下令死守四行仓库，但是因为本人的污点，不应该成为宣发时的素材。
历史虚无主义？ 历史虚无主义——指不加具体分析而盲目否定人类社会的历史发展过程
有人批评电影有历史虚无主义的嫌疑，认为一方面历史中日军并没有猛攻四行仓库，且电影中刻意夸大了国军的表现，认为事实中的国军并不是为了保卫上海而在电影中被“美化”，女学生送国旗也是从桥上光明正大地走过去而不是冒着子弹渡河。确实，电影确实在这方面有所夸张，但是电影之所以是电影而不是纪录片，为了表现主题而做适当的夸张处理，以此使感情的表达更加强烈，我觉得是可以接受的，在这一点上《八佰》确实也做到了。关于“美化”的问题，我觉得电影中处理的也比较恰当，如果我们交换时空设想一下，当时河对岸租界里的普通民众看来，对岸的中国军人在对抗日寇就是在保护自己（尽管他们也知道日军不会打到租界来），从谢晋元以及仓库里的士兵这些以执行军令为天职的军人看来，上级下达死守仓库的命令就是为了保卫上海最后一块领地而他们或许真的不知道这背后的真实目的是什么，电影中也表现了谢晋元团长的军人风度和民族气概以及士兵们视仓库为自己最后的坟墓，绝不后撤保卫上海的决心。在电影的最后，特使和谢团长的对峙中，戳破了这场战斗只是“表演”，只是为了在国际上获得同情，也是基本尊重史实的。所以我认为《八佰》出色地完成了它的任务，可以说它有虚构的成分，但最后宣扬的主题是没有问题的。既没有否定国军正面战场的妥协失利利用“表演”来博得国际社会同情的行为，也没有否定国军中也有像谢晋元及其部下英勇抗战的中国军人。
电影是好电影 电影最出彩的看点我认为是河两岸的这种天堂与地狱强烈对比，也是四行仓库保卫战带上一股特殊悲壮气氛的关键点，而电影中也得到了很着重的描写刻画，两岸如此相近又如此遥远，这种矛盾冲突让整部电影都笼罩在一种特殊的氛围当中，而且越是比较，越是压抑，一次次地用镜头画面冲击人心。电影中也运用了不少第一人称的镜头，无论是冲锋时突然满眼的鲜红色，还是深夜时对岸的灯红酒绿，都带给观众很强的心灵震撼。电影中也巧妙使用了关公意象，从对岸戏台上的表演到小湖北的想象，让观众更能体会到这场战役中仓库守军所面临的困境以及为国赴死的决心。
结局最后在“八百壮士”从桥面冲向租界撤退戛然而止，并在片尾拍摄了如今上海四行仓库的遗址，串起了历史与当今，这种对比让人更加感同身受。这是很标准的结尾，不出彩，但值得好评。
总结 总而言之，制作团队的努力不可否认，淞沪会战“八百壮士”的英雄事迹不该遗忘，有机会一定也去四行仓库遗址看看。最后，我希望这部电影能够走出中国，毕竟长期以来，欧洲战场太平洋战场的好片子太多了，作为东方主战场的中国，需要更多类似《八佰》这样的电影，在尊重历史的基础上，向世界展示中国在世界反法西斯战争中的决心和努力，无论是共军还是国军。
再给管大导演一个机会，期待他后面抗美援朝的片子。。。</description>
    </item>
    
    <item>
      <title>DeepClone深克隆</title>
      <link>https://kagaya85.github.io/2019/deepclone%E6%B7%B1%E5%85%8B%E9%9A%86/</link>
      <pubDate>Tue, 02 Jul 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/deepclone%E6%B7%B1%E5%85%8B%E9%9A%86/</guid>
      <description>DeepClone深克隆 之前去参加字节跳动面试的时候遇到了很尴尬的情况，连续两个面试官让我手写一个深克隆出来，尽管我明白需要深克隆的原因是什么，然而之前准备的时候虽然看到了有关深克隆的相关概念，因为看到“需要付出一定的性能代价，因此平常使用中需要尽量避免”这句话，于是便没有深究实现方法，结果当然也是没能够写出来。
于是打算利用这篇blog彻底理解这方面的概念和实现方法，也加深对JavaScript这门语言的认识
为什么会有深克隆的问题——谈谈弱类型 有深克隆就会有浅克隆，出现这两者的原因还是由于JavaScript的类型机制
说到类型机制，JavaScript作为一门弱类型的语言，在变量类型上帮助程序员做了太多的工作，由于我之前是以写C/C++为主，在刚接触JavaScript、Python和PHP的时候，惊奇于竟然有语言不需要再申明变量的时候使用类型定义符，感叹于总算不需要为某种变量不知该定义哪种类型头疼了。
于此同时，对于Python，PHP这种新变量直接赋值便可以使用的来说，我更喜欢JS的原因是有用于变量声明的var，const，let，因为这更贴近我所熟悉的C++语法，而PHP使用变量都需要打一个$符号也让我十分不习惯
当然有利就有弊，弱类型语言带来的最大的问题就是变量类型的不明确以及对于编辑器无法做出类型推导等。弱类型语言使得编译器（或解释器）不太去关注变量的类型，同时也会帮程序员做一些看不见的类型转换，虽然一定程度上让人可以更加专注于程序逻辑上，但往往会埋下一些潜在的问题
用一个最简单的例子
//javascript var a = 1 a = &amp;#34;123&amp;#34; var b = a + 1	// &amp;#39;1231&amp;#39; # python a = 1 a = &amp;#39;123&amp;#39; b = a + 1 # type error JavaScript是直接可以字符串+int值的，然而python中会报错，但是两者对于一个int型的变量赋值一个字符串都是合法的。这在c++里是不可想象的。
这就导致了在函数传参的时候又可能传进去参数的类型并不是所期待的类型，而这种错往往很难发现。
好在对于JavaScript，微软发明了一种TypeScript的语言作为JavaScript的超集，很好的解决了JavaScript最大的痛点，类型问题，而且在编辑器里有着很好的类型推导，这简直让人更加喜爱这门语言
话说回到深克隆问题
用过C++的人都知道，C++最大的一个优势之一就是凭借着指针类型变量可以方便的直接对内存进行操作。而对于JavaScript其实也是有指针变量，虽然并没有单独划分出一个类型而且功能没C++那么强大，但都是表示指向了内存的一块区域。
当时在学习C++类的拷贝构造函数时，老师就特意提醒对于类中的指针变量不可直接赋值，需要申请新的内存空间然后使用memcpy等函数进行内存复制。这是因为直接进行指针的赋值会导致多个指针指向同一块内存，引起访问冲突。而这，正是导致JavaScript中出现浅拷贝深拷贝问题的根源。
var a = [1, 2, 3] var b = a 在这里，a和b可以看作两个指针，同时指向了一个数组，对其中一个做出修改，另一个也会同时变化。
如果要实现一个浅克隆可以这样做
var a = [1, 2, 3] var b = [] for(let i = 0; i &amp;lt; a.</description>
    </item>
    
    <item>
      <title>Unix系统分析——锁</title>
      <link>https://kagaya85.github.io/2019/unix%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E9%94%81/</link>
      <pubDate>Tue, 25 Jun 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/unix%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E9%94%81/</guid>
      <description>Unix系统分析——锁 总结Unix系统中锁的相关知识
Linux各种锁的实现 原子操作 原子操作是最小的执行单位，保证在执行完毕前不会被其他任何事物或事件打断，也就是说不能有比它更小的执行单位，命名也借用了物理学中物质稳定存在的最小单位——原子。
原子操作于硬件架构相关，由汇编语言实现，一般用于实现计数等操作
信号量 信号量，Semaphore，Linux内核信号量以一个初始值创建，用来表示同时可以有几个任务可以访问由信号量保护的共享资源。初始值为1的信号量就是互斥锁，即在同一时间只能有一个任务可以访问信号量保护的共享资源
实现原理 当一个任务要访问一个由信号量保护的共享资源时，通过信号量提供的操作将信号量的值做减1操作，若此时值变为负数，表示当前资源不可得，该任务必须挂起进入等待队列直到该信号量可用；若值为非负数，表示成功获得信号量，可以访问共享资源。
在任务访问完毕后，需要释放获得的信号量，即通过对应操作将信号量的值加1实现，同时判断当前的值正负。若为非正数，表示当前在等待队列中有其他任务正在挂起等待，因此需要主动唤醒等待中的任务。
读写信号量 读写信号量将信号量按访问目的做了分类——读者和写者。读者对于共享资源只能做读操作，不能修改。而写着可以同时对共享资源进行读写。因为两者对共享变量做的操作不同，因此可以用以下访问规则：
  一个读写信号量可以同时拥有多个读者，即多个读者可以同时访问同一个共享资源
  读者获得读写信号量的前提是：
  当前没有被写者拥有
  没有写者在等待信号量释放
否则，读者需挂起等待写者释放信号量
    写者获得读写信号量的前提是：
  当前没有被其他读者或写者拥有
  没有其他写者在等待信号量释放
否则，写者需挂起等待直到没有任何访问
    总而言之，写者是独占访问资源的，具有排他性，同一时间只能有一个写者访问但对于多个读者可以同时访问。同时，为了保证写者不被饿死，只要有写者在等待，读者就不能进入访问，即使当前是其他读者在访问。
在Linux中，提供了将写者降级为读者的方法
void downgrade_write(struct rw_semaphore *sem); 函数用于把写者降级为读者。写者保持读写信号量期间，任何读者或写者都将无法访问该读写信号量保护的共享资源，对于那些当前条件下不需要写访问的写者，降级为读者将使得等待访问的读者能够立刻访问，从而增加了并发性，提高了效率。因此，读写信号量适用于读多写少的情况
自旋锁 spinlock，自旋锁与互斥锁最大的区别就是任务在调用自旋锁时不会入睡，若该自旋锁已经被占用，则调用者会一直循环等待锁的释放，也就是保持“自旋”。自旋锁适用于保持锁的时间非常短的情况，因此为了提高效率，选择自旋而不是入睡。
对比信号量来说，自旋锁可以在进程上下文和中断处理上下文中使用，而信号量只能在进程上下文中使用
在保持自旋锁的期间，进程是不放弃CPU的，而信号量在保持期间是可以放弃CPU的。对于可剥夺的Linux内核，单CPU的情况下，自旋锁只做了关闭中断和开启中断的操作。
读写锁 读写锁就是对自旋锁按访问目的划分为读者，写者，提高系统的并发度。
规则如下：
 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者 如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁  RCU RCU（Read-Copy Update），对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作
顺序锁 对读写锁的优化，读者不会被写者阻塞，意味着写者在进行写操作时读者仍然可以读取，读写是可以同时发生的，但写者之间依然互斥。
既然读写可以并行，为了保证数据的正确性依然有许多限制：
 被保护的资源不能有指针，否则当写者修改指针后，读者读取时可能失效 若读者读取时发生了写操作，读者需要重新读取数据  舒徐所适用于读写同时进行的概率较小的场景，允许读写同时进行，性能和并发度都有提高</description>
    </item>
    
    <item>
      <title>pthread多线程编程初探</title>
      <link>https://kagaya85.github.io/2019/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sat, 01 Jun 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/pthread%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/</guid>
      <description>pthread多线程编程初探 POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。
实验要求 使用pthread实现图像卷积的并行计算
由于之前使用MPI实现了一遍，相比与MPI，pthread是以共享内存的方式实现并行计算，所有有着系统开销更小，并行损耗更小的优点。但是也限制了pthread只能在一台机器上实现并行，不支持分布式计算。
基本概念 进程与线程 进程是一个程序运行的实例，一个进程对应系统运行中的一个任务，独占一部分系统资源。
随着人们对于并行计算的需求越来越多，而每次都开多个进程虽然可以实现并行计算，但带来的新的问题——进程间通信。这就需要涉及操作系统提供的进程通信方法（无名管道、有名管道、信号、消息队列、共享内存、Socket、共享文件），无论哪种方式，对于程序原来说需要单独编写通信相关代码还是过于麻烦。因此，懒惰的程序员们便提出了线程的概念。
线程是更小的任务实例，对于进程来说，每个进程有着自己独立的数据段（全局变量）、BSS段（未初始化的全局变量和静态变量）、以及堆栈段（局部变量），同一个程序的进程还有着共享的代码段。而对于线程来说，为了解决进程间通信的痛点，进程的数据段、bss段、堆在线程间共享，这样线程之间可以共享进程中的大部分数据，而且一个线程创建和销毁的开销的十分小，可以说很好的解决了fork多进程的问题。
当然新的机制必然会带来新的问题，比如说共享的数据空间就需要考虑写竞争和一些其他的同步问题，这都需要在实践中一点一点的学习
 在后面Unix系统分析的课程中了解到，其实linux中对于线程的管理也是按照进程的方式管理，只不过线程的地址空间与普通进程有区别，所以说linux中最小的任务实例还是进程
 Liunx的pthread 头文件
#include &amp;lt;pthread.h&amp;gt;创建线程
int pthread_create( pthread_t *restrict_tidp, const pthread_attr_t *restrict_attr, void *(*start_rtn)(void), void *restrict_arg ); 需要四个参数，分别对应：线程信息结构体，线程创建参数，线程入口函数，函数参数），四个参数均按地址传入，创建成功返回0，不成功代表创建失败
看一段代码
// pthread create if(pthread_create(&amp;amp;thread_id, NULL, thread_task, &amp;amp;paras[i]) &amp;lt; 0) { cerr &amp;lt;&amp;lt; &amp;#34;pthread_create error&amp;#34; &amp;lt;&amp;lt; endl; exit(-1); } thread_task为函数指针，对应线程要执行的函数入口，可以看到线程的执行是以一个函数为入口的，将可并行的部分放在函数中单独让线程执行，使用起来确实更加方便
回收线程
int pthread_join(pthread_t thread, void **retval); 第一个参数为回收的线程号，会阻塞等待，第二个参数对应线程状态结构体，将回收线程的状态复制到对应地址空间，若不关心线程结束状态，可传入NULL
编译
由于pthread.h不是标准库函数，之前需要指定-lpthread，但我发现gcc 7.3.0这样会报错找不到定义，只需要编译时指定-pthread参数即可编译成功
g++ pthread.cpp -o pthread -pthread 遇到的问题及解决方法 Id 有三个东西，pid，thread_id，tid</description>
    </item>
    
    <item>
      <title>CSS伪类的应用——实现聊天气泡效果</title>
      <link>https://kagaya85.github.io/2019/css%E4%BC%AA%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%B0%94%E6%B3%A1%E6%95%88%E6%9E%9C/</link>
      <pubDate>Fri, 17 May 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/css%E4%BC%AA%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E6%B0%94%E6%B3%A1%E6%95%88%E6%9E%9C/</guid>
      <description>CSS伪类的应用——实现聊天气泡效果 在做聊天室的时候为了实现一个气泡消息的效果，于是目标是要实现一个类似b站私信消息的感觉
主要原理是利用css伪类的:before和:after在圆角div前后插入两个方块，利用圆角叠加遮盖实现气泡的效果
消息气泡的模板定义如下
&amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;message&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;bubble&amp;#34;&amp;gt; &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 由于使用了vue，其中的&amp;lt;slot&amp;gt;为之后插入的消息内容
首先将bubble设置为圆角矩形，因为要适应内部文本大小且要占据一行，因此定义为inline-block，并用div包裹
.bubble{ display: inline-block; position: relative; padding: 15px; left: 0px; line-height: 1.2; background: #fff; border-radius: 15px; } 之后插入先后插入一个:before和:after块，位置定义为absolute（注意.bubble需定义为relative才能做到相对.bubble块偏移）
:before
.bubble:before { content: &amp;#39;&amp;#39;; position: absolute; top: -8px; left: -15px; height: 30px; width: 15px; background-color: #fff; border-bottom-left-radius: 40px 60px; } :after
.bubble:after { content: &amp;#39;&amp;#39;; position: absolute; top: -8px; left: -15px; width: 15px; height: 20px; background-color: #f2f2f2; border-bottom-left-radius: 100px 40px; } 这里的background-color和背景色设置为相同</description>
    </item>
    
    <item>
      <title>记人生中第一次面试</title>
      <link>https://kagaya85.github.io/2019/%E8%AE%B0%E4%BA%BA%E7%94%9F%E4%B8%AD%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Tue, 07 May 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/%E8%AE%B0%E4%BA%BA%E7%94%9F%E4%B8%AD%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</guid>
      <description>记人生中第一次面试 在准备暑期实习的时候第一个就投了微软，现在坐在面试后返回学校的地铁上，打开了md编辑器，准备写点什么。我想，无论结果如何，这都是对我来说十分有意义的一次体验。
微软分网测和面试两个部分，投简历后不久就先收到了网测通知的邮件，也就是某天下午7点到9点要在电脑前完成一个测试。邮件里附了一个考试连接和一个体验连接，后者可以让你提前熟悉一下操作环境，测试一下你的电脑环境（摄像头）。对了，网测通知的全程要开摄像头，也就是说会有监考，内容是两小时做四道题。但是我测的时候全程摄像头的指示灯都没有亮，甚至倒计时的计时器都是6小时？？？
考试界面和leetcode很像，题目都是英文的，前两道题比较简单，后两道难度一下就提高了。除非打过acm的选手或特别练过的，我觉得就算有思路也很难下手。当然我也只是完成了前两道，到了两小时就交卷了。
没想到过了几天竟然受到了微软的面试通知，这确实让我蛮惊喜意外的，但更多的还是不安。因为对于面试经验几乎为0的我来说，第一次就是面微软确实是一个巨大的挑战。准备时间大概只有两周，于是翻开了各大论坛的面经指南寻找准备方法。一直在忙于做各种课设的我也没怎么刷leetcode，甚至面试前在车上还在看全排列的题（我甚至没想到看的这道题三小时后就考了！！！🙄🙃👻）
面试是下午两点开始，由于我在嘉大荒，微软在闵大荒。3小时的路程让我不得不一大早9点就出发，结果还在微软的接待室坐了一小时。内心是紧张激动交织在一起，接待室微微的香味甚至让我一度想打瞌睡。后面又来了一波人好像是互相认识的，最后我们这波大概7、8个人的样子。HR小姐姐做完签到确认后就带我们到另外一个办公楼的休息室做等待。
然后就是等面试官一个个敲门叫自己的名字，然后带你去另一个房间面试。 我遇到的第一个面试官感觉人很好，在穿过办公区的时候还给我做介绍（我只能感叹不愧是微软）。到房间坐下后，一开始先让我做自我介绍，然后问了几个我简历上写的做过的项目，接着就是白板做题。
问题是机票按照先后顺序（出发地，目的地）排序的问题。我一开始先说了个谁都能想到的On2的方法，当然我肯定不会只到这。接着分析了下优化主要可以从查找效率入手，先是提了下二分搜索，最后还是落脚在了哈希表上。这样搜索基本可以达到常数效率。后来面试官和我一边讨论一些特殊情况，一边改进程序，感觉就像是老师学生在讨论题目，越说越有信心。感觉最后面试官也很满意，在带我回休息室的时候还问我要不要喝杯咖啡。
第二个面试官就感觉不是很顺利了，叫我的时候问我有没有简历（我：？？？），理论上每个面试官应该收到的都是电子版的简历，有些比较负责的可能会先去看你的简历，熟悉了以后在针对性的面试，所以他这么一问我只能说没有。于是他只能拿出手机看电子版简历，不过明显是第一次看，第一个就问我研究方向是什么？（我：？？？），我说明了下我是本科生后他好像有点失望，便将提问方向转向了有没有写代码的机会。我只能说代码肯定每天都在写，只是没有接触大项目的机会。于是同样问了几个之前的项目就开始做题，题目正是我两小时前还在看的全排列。我还有点惊喜，因为思路立马就有了，于是直接开始写。没用多久就完成了，是一个很简单的递归程序，我用最保险的方法写了。写完后便开始挑毛病，我发现我漏了一句pop，不过其他基本没什么逻辑上的错误。最后他觉得我写的复杂了，自己说了个插入的方法，确实这个方法我也看到过，但是不是很熟就没写。简单提了下他自己的思路后就结束了，二面大概只面了半小时，而且我觉得沟通不是很舒服，我感觉多半是凉了。于是两轮后就没有三轮了。
不过今天一天确实收获不少，很荣幸能微软一日游，也为今后如何准备面试提供了不少经验，感觉还是赚到了，给自己加油！</description>
    </item>
    
    <item>
      <title>SQL变量总结</title>
      <link>https://kagaya85.github.io/2019/sql%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 07 Apr 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/sql%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</guid>
      <description>SQL变量总结 变量分类  用户变量  以@开始，形式为@变量名 全局变量  set global 变量名 或者 set @@global.变量名 对所有客户端生效 只有具有super权限才可以设置全局变量   会话变量  用户变量与mysql客户端绑定，只对当前用户使用的客户端生效 只对连接的客户端生效     局部变量  declare专门用于声明 作用范围在begin和end语句块之间    定义方法  &amp;ldquo;=&amp;quot;,如 set @a =3,@a:=5 &amp;ldquo;:=&amp;quot;。select常常这样使用 set可以使用以上两种形式设置变量。而select只能使用&amp;rdquo;:=&amp;ldquo;的形式设置变量 未定义的变量初始化是null  示例题目： X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。
请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。
   id visit_date people     1 2017-01-01 10   2 2017-01-02 109   3 2017-01-03 150   4 2017-01-04 99   5 2017-01-05 145   6 2017-01-06 1455   7 2017-01-07 199   8 2017-01-08 188    对于上面实例数据，应当输出</description>
    </item>
    
    <item>
      <title>Mysql和MariaDB中的Rank排序的坑</title>
      <link>https://kagaya85.github.io/2019/mysql%E5%92%8Cmariadb%E4%B8%AD%E7%9A%84rank%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Mon, 01 Apr 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/mysql%E5%92%8Cmariadb%E4%B8%AD%E7%9A%84rank%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91/</guid>
      <description>Mysql和MariaDB中的Rank排序的坑 题目中需要对一个成绩表按考试科目以及学生做排名
为了加快之后其他步骤的查询速度，我想着将所有成绩都添加好排名后建立一个临时表
想法是
 先将score表中按考试课程升序，考试成绩降序，学号后两位升序做子查询 在新表中调用自定义的rank函数添加排名  rank函数是这样写的：
/* 临时rank function 要求原表按id score_mark降序 排列好 */ delimiter // drop function if exists myrank; create function myrank(score_id int, score_mark float) returns int READS SQL DATA begin if(@pre_score_id is null or @pre_score_id != score_id) then set @pre_score_id := score_id; set @pre_score_mark := score_mark; set @row := 1; set @rank := 1; else set @row := @row + 1; if(@pre_score_mark != score_mark or score_mark is null) then set @rank := @row; set @pre_score_mark = score_mark; end if; end if; return @rank; end // delimiter ; 完整的临时表建立过程如下，看起来结构很简单，只是对已经排好序的表统计排名：</description>
    </item>
    
    <item>
      <title>难得看次电影，随便写写</title>
      <link>https://kagaya85.github.io/2019/%E9%9A%BE%E5%BE%97%E7%9C%8B%E6%AC%A1%E7%94%B5%E5%BD%B1%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/</link>
      <pubDate>Fri, 08 Mar 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/%E9%9A%BE%E5%BE%97%E7%9C%8B%E6%AC%A1%E7%94%B5%E5%BD%B1%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/</guid>
      <description>难得看次电影，随便写写 ​	趁着周五+惊奇队长第一天上映，拉着基友去学校边上的电影院一睹为快，顺便看了广受好评的奥斯卡最佳影片——Green Book 绿皮书
​	不得不说我真是很庆幸自己先看了惊奇队长，再看了绿皮书，然后心满意足地回到寝室。先说说惊奇队长，作为复仇者联盟的最强战力，上映的这部《惊奇队长》基本上是为了一个月后的《复联4》做铺垫的。一方面为了新加入的成员交代好故事背景，另一方面补充一些主线上的剧情。总得来说没有什么惊喜的地方，哦，对我来说最惊喜的地方是能再次在荧幕上看到富瑞和科尔森，两位在神盾局中举足轻重的人物。说真的，富瑞那时候还没有戴他那个标志性的眼罩，而且显得非常年轻，体态虽然宽大但丝毫不显臃肿，甚至当时作为三级特工的富瑞已经显得十分老练。刚出场的时候我一时还没认出来，直到科尔森喊出富瑞的名字，我惊喜的差点叫出来。富瑞的形象一直是那样稳重，看到他总会给人一种莫名的安全感，仿佛一切都在他的掌握之中。惊喜之余，也顺便给神盾局上柱香。另外，关于剧情主要还是意料之中地交代了惊奇队长身世以及能力的来源，虽然可能没有人看这篇blog，但我还是没有剧透的习惯，就不细说了，个人觉得就算没有看《惊奇队长》对于接下来的复联也不会有什么影响，比较关键的内容就是宇宙魔方是怎么到富瑞手里的以及富瑞在《复联3》里联系惊奇队长的那个寻呼机的来历，不过全身发出耀眼光芒的女侠还是蛮帅的，就凭一个人就能单挑一支舰队的能力（特效）来看，还是非常适合边吃爆米花边看的。
​	看完《惊奇队长》紧接着就去看了一直被各种吹爆的《绿皮书》，没错，我也要吹爆“小绿本”了。之前看到海报上一个人开着一辆绿色的车，我大致就可以猜到这可能是一部公路电影，但不清楚具体的内容，如果没有获得这么高的舆论评价我可能也不会在影院下架前赶着去看了最后一场。对这类题材其实并不是很感冒，而且看过的公路片印象深的也并不多（如果阿甘也算的话），看完以后确实感叹，小绿本是真的物有所值，它值得那个小金人。
​	《绿皮书》的核心内容其实还是黑人与种族歧视问题，对于这种在美国算作政治正确题材的电影，就像国内抗日爱国题材的电影，总能成为稳定的创作素材，的确能让我获得如此舒服的观后体验着实出乎我的意料。尤其是整部电影从头到尾基本都保持在一个轻松愉快的气氛中，甚至在刚开始我误以为它是一部喜剧片。影片一开始展示的“本片改编自真实故事”确实就已经吸引了我的注意力，这种真人真事的电影确实更能说服观众。大致的内容就是一名退役的白人士兵，托尼，为了生计给一位黑人钢琴家，雪利，做司机，一路上陪伴他在美国的南部进行了两个月的巡演的故事。时间背景大致是在上个世纪，种族歧视在美国南部盛行的年代。这样题材的电影也很容易就落入俗套，比如很可能就是黑人兄弟们是怎样活在白人歧视和压迫下一步一步克服艰难获得成功的故事。当然，这样也可以是一部好电影，比如《42号传奇》，我还蛮喜欢这部的，推荐。
​	《绿皮书》中的黑人主角一开始就是功成名就的黑人音乐家，甚至受到总统邀请在白宫演奏过两次。于是，这次站在这样新颖一个角度来看待这样一个严肃的问题，编剧也似乎十分强调雪利的身份来营造一种对立，制造矛盾体，要知道，对于黑人中混的比较好的人，面对种族歧视时往往是白人黑人两边都不讨好，片中也有不少用雪利和在南方生活的普通黑人对比的镜头，有些还是蛮令人心酸的，比如在公路上修车那段，路边农场里的黑人农民隔着栅栏望着车里后座上的雪利，看着一位白人在给他开门，修车，大家不约而同地停下手中地农活，就这样一言不发地默默注视着雪利。这个片段从头到尾没有一句台词，长度可能也就几十秒，但是确是我最喜欢，意义最丰富的一段。
​	好的电影可能没必要通过悲伤的情景把你感动到流泪，或通过激烈的场面和配乐让你热血沸腾。也许可以是这样一部轻松愉快，让观影者不时发出欢笑声的电影，也能引发人们对问题矛盾的无限深思。
 2019年3月8日23点13分
 </description>
    </item>
    
    <item>
      <title>DitF第十三集ed绘本《魔物与王子》翻译</title>
      <link>https://kagaya85.github.io/2019/ditf%E7%AC%AC%E5%8D%81%E4%B8%89%E9%9B%86ed%E7%BB%98%E6%9C%AC%E9%AD%94%E7%89%A9%E4%B8%8E%E7%8E%8B%E5%AD%90%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Mon, 21 Jan 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/ditf%E7%AC%AC%E5%8D%81%E4%B8%89%E9%9B%86ed%E7%BB%98%E6%9C%AC%E9%AD%94%E7%89%A9%E4%B8%8E%E7%8E%8B%E5%AD%90%E7%BF%BB%E8%AF%91/</guid>
      <description>DitF第十三集ed绘本《魔物与王子》翻译 一个挺悲伤的故事（有翻译错误还请指教）
在某个国家漆黑的森林深处，有一个不为人知的种族生活在那里。背上长着巨大的他们十分的美丽，但是确实被成为“魔物”般的存在。那里生活着的“魔物”的公主。她的背上也有着巨大的灰色翅膀，当她成长到十六岁的时候，就被允许用翅膀飞到森林的外面。
然后，当过完十六岁生日的时候，公主第一次飞出森林，穿越过了险峻的山峰，飞过了河流。好不容易到达了一个住着不同种族的地方——人类的国家。空中的月光照映着她的脸庞。
她降落在了大城市中的庭院里，看到了一个独自仰望着月亮的青年的身影。公主躲在树林中注视着青年的身影。那是第一次萌生了恋爱的感觉。但是，他明显和自己是不同的种族。从来没有魔物和人类结成伴侣的事情发生。
公主便去拜访了住在森林里的魔女，对魔女说：“我想和人类一起生活，想和那个人结婚”“好啊，用你的翅膀来交换，但是你要记住。无论伪装成什么样，只要身为魔物的你在他身边，就会吞噬王子的生命。” 当背上巨大的翅膀被取下，至今从未感受过的恐惧向公主袭来，再也无法飞上天空。即使这样公主还是很高兴，边哭边笑的说到：“人类！人类！我变得和那个人一样了”
于是，公主再次用自己的脚向人类的国家走去，在沙漠中遇到了人影。“不好了！谁能来救救这个人啊！”那里有一个脚被毒蛇咬了的青年的身影。公主急忙上去亲自把毒从被蛇咬的伤口中吸出来。“谢谢你。多么勇敢的人啊。我是这个国家的王子” 这位王子就是公主在那天城里遇到的青年。“你是救了我命的人，请和我结婚。”
很快举行了结婚仪式，神父询问穿着洁白婚纱的公主，“你是否发誓，无论疾病还是健康的时候，至死都不会把你们分开” “是的，我发誓“ 互相交换了结婚戒指，在神父的指引下立下誓约之吻，”让我们祝福救了王子性命的这位勇敢的少女！“ 在巨大的欢呼声中，整个国家都洋溢着喜悦的气氛。
“人类，人类！即使没有能飞上天空的强力的翅膀，也没有尖锐的牙齿和爪子。弱小无力的生物，确是这样的温柔。人类真是太棒了” 之后，作为人类国家的公主，度过了一个又一个幸福的日子。在旁边一直支持着王子的工作。时常好好地游览了各种各样的地方，如蓝宝石般散发着光芒的大海、闪闪发光的草原、像燃烧的火焰般的极光。公主握着王子的手，微笑着看着他“我们不会分开的对吧。xxxx（模糊）”
但是，公主的幸福并没有持续很久，在身体如同灼烧一般的疼痛中醒来，自己的身体也渐渐变成一个丑陋的怪物，尖锐的利爪迅速的生长。“为什么？我应该已经拜托了她让我成为了人类啊”，然后，她的背后丑陋漆黑的翅膀突破皮肉展开来。“既然使用了魔法也是有代价的。你已经作为完美的人类获得了幸福了吧，之后你自己只是会丧失自己，变成丑陋得怪物而已罢了。” 森之魔女的声音一句句传到她的耳边。“但是，只要你亲手杀掉你最亲爱的人，你就会解除诅咒，变回你最初始的样子”
公主看着自己心爱的王子，将自己长长的爪子伸向了王子的脖子。明明是比谁都要喜爱的人啊，如今却涌来了想要切断他的喉咙杀死他的感觉。公主拼命的控制自己，自己的手也渐渐渗出了血。“只要杀掉王子，诅咒就会解除……” 公主流着泪，轻轻的亲了下王子的脸颊。
王子醒来后发现公主并不在身边，而是在床上发现了许多漆黑的羽毛。王子十分悲伤，即使在全城中寻找，却再也没有人见过公主。</description>
    </item>
    
    <item>
      <title>我们都在向前走，只有回忆驻留在原地</title>
      <link>https://kagaya85.github.io/2019/%E6%88%91%E4%BB%AC%E9%83%BD%E5%9C%A8%E5%90%91%E5%89%8D%E8%B5%B0%E5%8F%AA%E6%9C%89%E5%9B%9E%E5%BF%86%E9%A9%BB%E7%95%99%E5%9C%A8%E5%8E%9F%E5%9C%B0/</link>
      <pubDate>Fri, 18 Jan 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/%E6%88%91%E4%BB%AC%E9%83%BD%E5%9C%A8%E5%90%91%E5%89%8D%E8%B5%B0%E5%8F%AA%E6%9C%89%E5%9B%9E%E5%BF%86%E9%A9%BB%E7%95%99%E5%9C%A8%E5%8E%9F%E5%9C%B0/</guid>
      <description>我们都在向前走，只有回忆驻留在原地 电影《肆式青春》短评
观看建议：这部电影是三位导演通过中国这个舞台来描绘他们眼中青春的故事，三个篇章之间关系不大，但各自讲述一段完整的故事，虽然篇幅较短，但请用心体会，如果能在将自己的经历带入其中一段故事中的话能获得最好的观看体验。
首先很遗憾，限于排片过少没能够第一时间去影院支持一下。其实很早就开始关注这部电影了，随着中国资本进入动画市场，也一直期待着有能有一部讲述中国自己故事的动画，不得不说，绘梦这次做的不错。整体看完以后觉得基本上没让我失望，个人看来第一篇与第三篇是比较出彩的，可以看到叫兽和李导真的是十分想把属于那个时代的回忆和情感通过动画的形式传达出来，各个细节十分到位，电影中的各种中国式场景想必各位也看得十分有亲切感。也许限于篇幅原因，有许多内容没能够呈现出来，但也确实足够表现出两位在中国这片土地上长大的年轻人对于那个一段美好时光的不舍之情，叙事节奏的把握我觉得真的是十分不错了。但我觉得缺点也是有的，题材的限制使得只有相似经历的人更容易在这个电影里获得共鸣，另外篇幅限制使得许多地方存在铺垫不足的问题。但个人认为这些不至于影响到整个电影所表达的东西，所以我还是会推荐更多人来看的。 正如《一碗乡愁》的导演叫兽所说的一样，他的目的是要引起一部分人的共鸣，如果你在看这部电影的时候，电影中的一个事物，一个情节，或者一个人物，能让你不由自主地将自己代入到电影之中，那可以说这部电影是成功的。无论是自己的那位和蔼的长辈，还是小时候最喜欢的一道美食，抑或是那个曾经羞涩的自己所暗恋的ta。尽管每个人的青春时光都不尽相同，但大家都经历过那个年代，总能找到一些只属于那个年代的印记，电影讲述的不只是导演们自己的故事，也是在讲述我们每一个80后，90后甚至00后的青春。
我们都在向前走，只有回忆驻留在原地。如今，我也只能借助这样一部电影，才能够回忆起曾经那个傻傻的自己了。</description>
    </item>
    
    <item>
      <title>打算重启kgyzone</title>
      <link>https://kagaya85.github.io/2019/%E6%89%93%E7%AE%97%E9%87%8D%E5%90%AFkgyzone/</link>
      <pubDate>Tue, 01 Jan 2019 21:30:20 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2019/%E6%89%93%E7%AE%97%E9%87%8D%E5%90%AFkgyzone/</guid>
      <description>打算重启kgyzone 离建好kgyzone也过去一年多了，本来想好好在这里总结一下身边发生的事情，或是做一些技术记录，然而一直没有掌握worldpress的正确使用方法，人嘛，总想在走过的地方留下点什么东西，哪怕是一个脚印也好，好证明自己也曾存在过。
之后可以慢慢在这里发一下心得体会。或许可以直接将markdown格式的文件直接发上来，那样的话会方便很多。
markdown真好用啊</description>
    </item>
    
  </channel>
</rss>
