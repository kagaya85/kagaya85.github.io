<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on かがやの部屋</title>
    <link>https://example.com/tags/database/</link>
    <description>Recent content in Database on かがやの部屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 07 Apr 2019 21:30:20 +0800</lastBuildDate><atom:link href="https://example.com/tags/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQL变量总结</title>
      <link>https://example.com/p/2019/sql%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 07 Apr 2019 21:30:20 +0800</pubDate>
      
      <guid>https://example.com/p/2019/sql%E5%8F%98%E9%87%8F%E6%80%BB%E7%BB%93/</guid>
      <description>SQL变量总结 变量分类  用户变量  以@开始，形式为@变量名 全局变量  set global 变量名 或者 set @@global.变量名 对所有客户端生效 只有具有super权限才可以设置全局变量   会话变量  用户变量与mysql客户端绑定，只对当前用户使用的客户端生效 只对连接的客户端生效     局部变量  declare专门用于声明 作用范围在begin和end语句块之间    定义方法  &amp;ldquo;=&amp;quot;,如 set @a =3,@a:=5 &amp;ldquo;:=&amp;quot;。select常常这样使用 set可以使用以上两种形式设置变量。而select只能使用&amp;rdquo;:=&amp;ldquo;的形式设置变量 未定义的变量初始化是null  示例题目： X 市建了一个新的体育馆，每日人流量信息被记录在这三列信息中：序号 (id)、日期 (date)、 人流量 (people)。
请编写一个查询语句，找出高峰期时段，要求连续三天及以上，并且每天人流量均不少于100。
   id visit_date people     1 2017-01-01 10   2 2017-01-02 109   3 2017-01-03 150   4 2017-01-04 99   5 2017-01-05 145   6 2017-01-06 1455   7 2017-01-07 199   8 2017-01-08 188    对于上面实例数据，应当输出</description>
    </item>
    
    <item>
      <title>Mysql和MariaDB中的Rank排序的坑</title>
      <link>https://example.com/p/2019/mysql%E5%92%8Cmariadb%E4%B8%AD%E7%9A%84rank%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91/</link>
      <pubDate>Mon, 01 Apr 2019 21:30:20 +0800</pubDate>
      
      <guid>https://example.com/p/2019/mysql%E5%92%8Cmariadb%E4%B8%AD%E7%9A%84rank%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%91/</guid>
      <description>Mysql和MariaDB中的Rank排序的坑 题目中需要对一个成绩表按考试科目以及学生做排名
为了加快之后其他步骤的查询速度，我想着将所有成绩都添加好排名后建立一个临时表
想法是
 先将score表中按考试课程升序，考试成绩降序，学号后两位升序做子查询 在新表中调用自定义的rank函数添加排名  rank函数是这样写的：
/* 临时rank function 要求原表按id score_mark降序 排列好 */ delimiter // drop function if exists myrank; create function myrank(score_id int, score_mark float) returns int READS SQL DATA begin if(@pre_score_id is null or @pre_score_id != score_id) then set @pre_score_id := score_id; set @pre_score_mark := score_mark; set @row := 1; set @rank := 1; else set @row := @row + 1; if(@pre_score_mark != score_mark or score_mark is null) then set @rank := @row; set @pre_score_mark = score_mark; end if; end if; return @rank; end // delimiter ; 完整的临时表建立过程如下，看起来结构很简单，只是对已经排好序的表统计排名：</description>
    </item>
    
  </channel>
</rss>
