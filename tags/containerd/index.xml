<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Containerd on かがやの部屋</title>
    <link>https://kagaya85.github.io/tags/containerd/</link>
    <description>Recent content in Containerd on かがやの部屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 17 Dec 2020 23:31:25 +0800</lastBuildDate><atom:link href="https://kagaya85.github.io/tags/containerd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Kubernetes V1.20.0 与 Containerd 配置K8s集群</title>
      <link>https://kagaya85.github.io/2020/%E4%BD%BF%E7%94%A8kubernetes-v1.20.0-%E4%B8%8E-containerd-%E9%85%8D%E7%BD%AEk8s%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Thu, 17 Dec 2020 23:31:25 +0800</pubDate>
      
      <guid>https://kagaya85.github.io/2020/%E4%BD%BF%E7%94%A8kubernetes-v1.20.0-%E4%B8%8E-containerd-%E9%85%8D%E7%BD%AEk8s%E9%9B%86%E7%BE%A4/</guid>
      <description>使用Kubernetes V1.20.0 与 Containerd 配置K8s集群 写在前面 Kubernetes在最新的1.20.0版本中表示正式放弃了Docker，原来的Docker项目也早已改名为Moby了，即便Docker在容器技术中仍占据主流，并且在其他地方也能够继续发光发热，但从长远来看，容器运行时必然也会进入一个多方竞争的时代。对于适配了Kubernetes CRI的容器运行时，我们便有了很多选择，如Containerd和CRI-O。Docker目前占据了约七成的份额，而第二名Containerd也占据了两成多。刚好实验室有搭建集群的需求，作为爱折腾星人，决定紧跟时代，用最新的V1.20.0的Kubernetes与Containerd来搭建我们的实验集群。我会简单讲解我的配置过程以及中间遇到的问题及解决方法，毕竟自己踩过的坑，得讲一遍才能记得深刻（笑）
配置基本环境 这次打算在四台裸机上部署一个单master节点，三个worker节点的小集群，单机配置如下：
  CleanShot_2020-12-18_at_21.54.34@2x 
当然这是我部署好后的截图，主机的名称也改为了ip+nodeType，方便识别当前主机，当然这也是必须修改的，因为原来的四台主机的主机名都为localhost.localdomain，同名主机在建立集群后不能一起显示，这也是配置时遇到的坑之一，所以我也同样将改名的命令分别写在了04_pull_master_images.sh与04_pull_worker_images.sh，可以自动实现将主机名替换为ip+nodeType，当然，这都是后话了。
本次主要是在CentOS7下进行配置，要求能连接外网，对于kubernets需要的k8s.gcr.io上的镜像我也已经在阿里云上同步了一份，所以没有挂代理的要求。当然最好还是在root用户下执行，不保证非root用户的执行效果（可增加sudo尝试）
对于每一台机器，只需要一次执行00～02对应脚本
# cd进入脚本对应目录 bash 00_install_tools.sh bash 01_config_env.sh bash 02_install_kube.sh   00安装了一些必要的工具，如git、vim、unzip、ntpdate等，安装了yum epel并对yum进行了换源。除此之外，还包含一些常用的工具如zsh、neofetch、htop等，同时也会将shell切换为zsh（⚠️注意，后文的脚本都是基于修改~/.zshrc文件，如果不使用zsh，请对应修改为~/.bashrc或~./bash_profile），这里可以根据自己的需要做修改。
  01设置了一些基本环境配置，关闭firewalld和swap，设置了iptable转发等，特别是对时间进行同步，并修改为CST时区，保证各个主机上时间的一致性对集群的配置也至关重要。
  02为yum添加了Kubernetes的repo，安装了1.20.0版本的kubelet、kubeadm、kubectl三件套
  安装Containerd 接下来，我们为每一台主机安装Containerd替换之前的Docker。
一键安装：
bash 03_install_containerd.sh Containerd的官方quick-start文档会默认你已经安装了runc（Containerd默认的容器运行工具），所以第一步我们还是要安装runc，否则将无法运行容器。
我们直接选择拉取runc的官方仓库进行编译安装，runc比较小，编译很快，但是需要有go的运行环境和libseccomp 、libseccomp-devel两个链接库，可以参考这里。这些都在脚本中安装好了，如果你不想编译，也可以下载编译好的二进制文件放到$PATH对应的目录中即可。
# install runc git clone https://github.com/opencontainers/runc cd runc &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install 这样就安装好了runc工具
安装Containerd也很简单，直接下载官方编译好的二进制压缩包，解压对应目录，这里我也选择了较新的1.4.3版本，甚至官方仓库的release tag里还是1.3.9版本
CONTAINERD_VERSION=1.4.3 wget https://github.com/containerd/containerd/releases/download/v&amp;#34;$CONTAINERD_VERSION&amp;#34;/containerd-&amp;#34;$CONTAINERD_VERSION&amp;#34;-linux-amd64.tar.gz tar -xvf containerd-&amp;#34;$CONTAINERD_VERSION&amp;#34;-linux-amd64.tar.gz -C /usr/local/ 接下来就是比较关键也是我当时遇到问题最多的地方：containerd配置</description>
    </item>
    
  </channel>
</rss>
