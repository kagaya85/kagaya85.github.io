<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Kagaya&#39;s house</title>
    <link>http://example.org/tags/linux/</link>
    <description>Recent content in Linux on Kagaya&#39;s house</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 25 Jun 2019 21:30:20 +0800</lastBuildDate>
    
	<atom:link href="http://example.org/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unix系统分析——锁</title>
      <link>http://example.org/2019/lock/</link>
      <pubDate>Tue, 25 Jun 2019 21:30:20 +0800</pubDate>
      
      <guid>http://example.org/2019/lock/</guid>
      <description>Unix系统分析——锁 总结Unix系统中锁的相关知识
Linux各种锁的实现 原子操作 原子操作是最小的执行单位，保证在执行完毕前不会被其他任何事物或事件打断，也就是说不能有比它更小的执行单位，命名也借用了物理学中物质稳定存在的最小单位——原子。
原子操作于硬件架构相关，由汇编语言实现，一般用于实现计数等操作
信号量 信号量，Semaphore，Linux内核信号量以一个初始值创建，用来表示同时可以有几个任务可以访问由信号量保护的共享资源。初始值为1的信号量就是互斥锁，即在同一时间只能有一个任务可以访问信号量保护的共享资源
实现原理 当一个任务要访问一个由信号量保护的共享资源时，通过信号量提供的操作将信号量的值做减1操作，若此时值变为负数，表示当前资源不可得，该任务必须挂起进入等待队列直到该信号量可用；若值为非负数，表示成功获得信号量，可以访问共享资源。
在任务访问完毕后，需要释放获得的信号量，即通过对应操作将信号量的值加1实现，同时判断当前的值正负。若为非正数，表示当前在等待队列中有其他任务正在挂起等待，因此需要主动唤醒等待中的任务。
读写信号量 读写信号量将信号量按访问目的做了分类——读者和写者。读者对于共享资源只能做读操作，不能修改。而写着可以同时对共享资源进行读写。因为两者对共享变量做的操作不同，因此可以用以下访问规则：
  一个读写信号量可以同时拥有多个读者，即多个读者可以同时访问同一个共享资源
  读者获得读写信号量的前提是：
  当前没有被写者拥有
  没有写者在等待信号量释放
否则，读者需挂起等待写者释放信号量
    写者获得读写信号量的前提是：
  当前没有被其他读者或写者拥有
  没有其他写者在等待信号量释放
否则，写者需挂起等待直到没有任何访问
    总而言之，写者是独占访问资源的，具有排他性，同一时间只能有一个写者访问但对于多个读者可以同时访问。同时，为了保证写者不被饿死，只要有写者在等待，读者就不能进入访问，即使当前是其他读者在访问。
在Linux中，提供了将写者降级为读者的方法
void downgrade_write(struct rw_semaphore *sem); 函数用于把写者降级为读者。写者保持读写信号量期间，任何读者或写者都将无法访问该读写信号量保护的共享资源，对于那些当前条件下不需要写访问的写者，降级为读者将使得等待访问的读者能够立刻访问，从而增加了并发性，提高了效率。因此，读写信号量适用于读多写少的情况
自旋锁 spinlock，自旋锁与互斥锁最大的区别就是任务在调用自旋锁时不会入睡，若该自旋锁已经被占用，则调用者会一直循环等待锁的释放，也就是保持“自旋”。自旋锁适用于保持锁的时间非常短的情况，因此为了提高效率，选择自旋而不是入睡。
对比信号量来说，自旋锁可以在进程上下文和中断处理上下文中使用，而信号量只能在进程上下文中使用
在保持自旋锁的期间，进程是不放弃CPU的，而信号量在保持期间是可以放弃CPU的。对于可剥夺的Linux内核，单CPU的情况下，自旋锁只做了关闭中断和开启中断的操作。
读写锁 读写锁就是对自旋锁按访问目的划分为读者，写者，提高系统的并发度。
规则如下：
 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者 如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁  RCU RCU（Read-Copy Update），对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作
顺序锁 对读写锁的优化，读者不会被写者阻塞，意味着写者在进行写操作时读者仍然可以读取，读写是可以同时发生的，但写者之间依然互斥。
既然读写可以并行，为了保证数据的正确性依然有许多限制：
 被保护的资源不能有指针，否则当写者修改指针后，读者读取时可能失效 若读者读取时发生了写操作，读者需要重新读取数据  舒徐所适用于读写同时进行的概率较小的场景，允许读写同时进行，性能和并发度都有提高</description>
    </item>
    
  </channel>
</rss>