<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Kagaya">
  <meta name="description" content="Kagaya&#39;s personal blog">
  <meta name="keywords" content="computer science technology blog">
  
  <link rel="prev" href="https://kagaya85.github.io/2019/css%E6%B0%94%E6%B3%A1/" />
  <link rel="next" href="https://kagaya85.github.io/2019/lock/" />
  <link rel="canonical" href="https://kagaya85.github.io/2019/pthread/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           pthread多线程编程初探 | Kagaya&#39;s house
       
  </title>
  <meta name="title" content="pthread多线程编程初探 | Kagaya&#39;s house">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/kagaya85.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "pthread多线程编程初探",
    "headline" : "pthread多线程编程初探",
    "description" : "pthread多线程编程初探 POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。\n实验要求 使用pthread实现图像卷积的并行计算\n由于之前使用MPI实现了一遍，相比与MPI，pthread是以共享内存的方式实现并行计算，所有有着系统开销更小，并行损耗更小的优点。但是也限制了pthread只能在一台机器上实现并行，不支持分布式计算。\n基本概念 进程与线程 进程是一个程序运行的实例，一个进程对应系统运行中的一个任务，独占一部分系统资源。\n随着人们对于并行计算的需求越来越多，而每次都开多个进程虽然可以实现并行计算，但带来的新的问题——进程间通信。这就需要涉及操作系统提供的进程通信方法（无名管道、有名管道、信号、消息队列、共享内存、Socket、共享文件），无论哪种方式，对于程序原来说需要单独编写通信相关代码还是过于麻烦。因此，懒惰的程序员们便提出了线程的概念。\n线程是更小的任务实例，对于进程来说，每个进程有着自己独立的数据段（全局变量）、BSS段（未初始化的全局变量和静态变量）、以及堆栈段（局部变量），同一个程序的进程还有着共享的代码段。而对于线程来说，为了解决进程间通信的痛点，进程的数据段、bss段、堆在线程间共享，这样线程之间可以共享进程中的大部分数据，而且一个线程创建和销毁的开销的十分小，可以说很好的解决了fork多进程的问题。\n当然新的机制必然会带来新的问题，比如说共享的数据空间就需要考虑写竞争和一些其他的同步问题，这都需要在实践中一点一点的学习\n 在后面Unix系统分析的课程中了解到，其实linux中对于线程的管理也是按照进程的方式管理，只不过线程的地址空间与普通进程有区别，所以说linux中最小的任务实例还是进程\n Liunx的pthread 头文件\n#include \u0026lt;pthread.h\u0026gt;创建线程\nint pthread_create( pthread_t *restrict_tidp, const pthread_attr_t *restrict_attr, void *(*start_rtn)(void), void *restrict_arg ); 需要四个参数，分别对应：线程信息结构体，线程创建参数，线程入口函数，函数参数），四个参数均按地址传入，创建成功返回0，不成功代表创建失败\n看一段代码\n\/\/ pthread create if(pthread_create(\u0026amp;thread_id, NULL, thread_task, \u0026amp;paras[i]) \u0026lt; 0) { cerr \u0026lt;\u0026lt; \u0026#34;pthread_create error\u0026#34; \u0026lt;\u0026lt; endl; exit(-1); } thread_task为函数指针，对应线程要执行的函数入口，可以看到线程的执行是以一个函数为入口的，将可并行的部分放在函数中单独让线程执行，使用起来确实更加方便\n回收线程\nint pthread_join(pthread_t thread, void **retval); 第一个参数为回收的线程号，会阻塞等待，第二个参数对应线程状态结构体，将回收线程的状态复制到对应地址空间，若不关心线程结束状态，可传入NULL\n编译\n由于pthread.h不是标准库函数，之前需要指定-lpthread，但我发现gcc 7.3.0这样会报错找不到定义，只需要编译时指定-pthread参数即可编译成功\ng\u002b\u002b pthread.cpp -o pthread -pthread 遇到的问题及解决方法 Id 有三个东西，pid，thread_id，tid",
    "inLanguage" : "zh-cn",
    "author" : "Kagaya",
    "creator" : "Kagaya",
    "publisher": "Kagaya",
    "accountablePerson" : "Kagaya",
    "copyrightHolder" : "Kagaya",
    "copyrightYear" : "2019",
    "datePublished": "2019-06-01 21:30:20 \u002b0800 CST",
    "dateModified" : "2019-06-01 21:30:20 \u002b0800 CST",
    "url" : "https:\/\/kagaya85.github.io\/2019\/pthread\/",
    "wordCount" : "212",
    "keywords" : [ "C\u002b\u002b","Pthread","并行计算", "Kagaya\u0027s house"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://kagaya85.github.io/">Kagaya&#39;s house</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://kagaya85.github.io/">Kagaya&#39;s house</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">pthread多线程编程初探</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://kagaya85.github.io/" rel="author">Kagaya</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-06-01 itemprop="datePublished">June 1, 2019</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://kagaya85.github.io/categories/code/"> Code </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h1 id="pthread多线程编程初探">pthread多线程编程初探</h1>
<p><strong>POSIX线程</strong>（POSIX threads），简称Pthreads，是线程的<strong>POSIX标准</strong>。该标准定义了创建和操纵线程的一整套API。</p>
<h2 id="实验要求">实验要求</h2>
<p><strong>使用pthread实现图像卷积的并行计算</strong></p>
<p>由于之前使用MPI实现了一遍，相比与MPI，pthread是以共享内存的方式实现并行计算，所有有着系统开销更小，并行损耗更小的优点。但是也限制了pthread只能在一台机器上实现并行，不支持分布式计算。</p>
<h2 id="基本概念">基本概念</h2>
<h3 id="进程与线程">进程与线程</h3>
<p>进程是一个程序运行的实例，一个进程对应系统运行中的一个任务，独占一部分系统资源。</p>
<p>随着人们对于并行计算的需求越来越多，而每次都开多个进程虽然可以实现并行计算，但带来的新的问题——进程间通信。这就需要涉及操作系统提供的进程通信方法（无名管道、有名管道、信号、消息队列、共享内存、Socket、共享文件），无论哪种方式，对于程序原来说需要单独编写通信相关代码还是过于麻烦。因此，懒惰的程序员们便提出了线程的概念。</p>
<p>线程是更小的任务实例，对于进程来说，每个进程有着自己独立的数据段（全局变量）、BSS段（未初始化的全局变量和静态变量）、以及堆栈段（局部变量），同一个程序的进程还有着共享的代码段。而对于线程来说，为了解决进程间通信的痛点，进程的数据段、bss段、堆在线程间共享，这样线程之间可以共享进程中的大部分数据，而且一个线程创建和销毁的开销的十分小，可以说很好的解决了fork多进程的问题。</p>
<p>当然新的机制必然会带来新的问题，比如说共享的数据空间就需要考虑写竞争和一些其他的同步问题，这都需要在实践中一点一点的学习</p>
<blockquote>
<p>在后面Unix系统分析的课程中了解到，其实linux中对于线程的管理也是按照进程的方式管理，只不过线程的地址空间与普通进程有区别，所以说linux中最小的任务实例还是进程</p>
</blockquote>
<h3 id="liunx的pthread">Liunx的pthread</h3>
<p><strong>头文件</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span></code></pre></div><p><strong>创建线程</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_create</span>(
    pthread_t <span style="color:#f92672">*</span>restrict_tidp,
    <span style="color:#66d9ef">const</span> pthread_attr_t <span style="color:#f92672">*</span>restrict_attr,
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>start_rtn)(<span style="color:#66d9ef">void</span>),
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>restrict_arg
    );
</code></pre></div><p>需要四个参数，分别对应：线程信息结构体，线程创建参数，线程入口函数，函数参数），四个参数均按地址传入，创建成功返回0，不成功代表创建失败</p>
<p>看一段代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// pthread create
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(pthread_create(<span style="color:#f92672">&amp;</span>thread_id, NULL, thread_task, <span style="color:#f92672">&amp;</span>paras[i]) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
{
    cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;pthread_create error&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>thread_task为函数指针，对应线程要执行的函数入口，可以看到线程的执行是以一个函数为入口的，将可并行的部分放在函数中单独让线程执行，使用起来确实更加方便</p>
<p><strong>回收线程</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_join</span>(pthread_t <span style="color:#66d9ef">thread</span>, <span style="color:#66d9ef">void</span> <span style="color:#f92672">**</span>retval);
</code></pre></div><p>第一个参数为回收的线程号，会阻塞等待，第二个参数对应线程状态结构体，将回收线程的状态复制到对应地址空间，若不关心线程结束状态，可传入NULL</p>
<p><strong>编译</strong></p>
<p>由于<code>pthread.h</code>不是标准库函数，之前需要指定<code>-lpthread</code>，但我发现gcc 7.3.0这样会报错找不到定义，只需要编译时指定<code>-pthread</code>参数即可编译成功</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">g++ pthread.cpp -o pthread -pthread
</code></pre></div><h2 id="遇到的问题及解决方法">遇到的问题及解决方法</h2>
<h3 id="id">Id</h3>
<p>有三个东西，pid，thread_id，tid</p>
<p>对于一个进程来说：</p>
<ul>
<li>pid就是进程id，和thread_id相等</li>
</ul>
<p>对于一个进程的许多线程来说：</p>
<ul>
<li>thread_id与pid不同，而且不是一个从0开始的数</li>
<li>thread_id在该进程内不相同，可能与其他进程的线程thread_id相同</li>
<li>由于之前提到的，linux对于线程的管理也是按进程的方式，所以线程也有一个pid，称为tid，可以使用系统调用获取。</li>
<li>若需要项其他进程的线程发送信息，就需要使用tid来标识对应线程，而不是pid或者thread_id</li>
</ul>
<h3 id="传递参数时地址共享问题">传递参数时地址共享问题</h3>
<p>由于需要传递多个参数，采用结构体<code>task_para</code>传值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">task_para paras;
<span style="color:#75715e">// pthread create
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> thread_num; i<span style="color:#f92672">++</span>) 
{
    paras.thread_num <span style="color:#f92672">=</span> thread_num;
    paras.my_num <span style="color:#f92672">=</span> i;
    paras.start_line <span style="color:#f92672">=</span> i <span style="color:#f92672">*</span> BmpHeight <span style="color:#f92672">/</span> thread_num;
    paras.end_line <span style="color:#f92672">=</span> paras[i].start_line <span style="color:#f92672">+</span> BmpHeight <span style="color:#f92672">/</span> thread_num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span>(pthread_create(<span style="color:#f92672">&amp;</span>thread_id, NULL, thread_task, <span style="color:#f92672">&amp;</span>paras) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
    {
        cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;pthread_create error&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> paras.my_num <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; start.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    threads.push_back(thread_id);
}
</code></pre></div><p>传递参数时传递不同地址的结构体</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">task_para<span style="color:#f92672">*</span> paras <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> task_para[thread_num];    
<span style="color:#75715e">// pthread create
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> thread_num; i<span style="color:#f92672">++</span>) 
{
    paras[i].thread_num <span style="color:#f92672">=</span> thread_num;
    paras[i].my_num <span style="color:#f92672">=</span> i;
    paras[i].start_line <span style="color:#f92672">=</span> i <span style="color:#f92672">*</span> BmpHeight <span style="color:#f92672">/</span> thread_num;
    paras[i].end_line <span style="color:#f92672">=</span> paras[i].start_line <span style="color:#f92672">+</span> BmpHeight <span style="color:#f92672">/</span> thread_num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span>(pthread_create(<span style="color:#f92672">&amp;</span>thread_id, NULL, thread_task, <span style="color:#f92672">&amp;</span>paras[i]) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
    {
        cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;pthread_create error&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> paras[i].my_num <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; start.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    threads.push_back(thread_id);
}
</code></pre></div><p>以上就是这次实验中总结的一些知识点，当然thread还有许多用法没有去实践，之后用OpenMP来实现卷积时再打算总结一下各自优劣吧。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Kagaya </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://kagaya85.github.io/2019/pthread/>https://kagaya85.github.io/2019/pthread/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://kagaya85.github.io/tags/c&#43;&#43;/">
                    #C&#43;&#43;</a></span>
            
            <span class="tag"><a href="https://kagaya85.github.io/tags/pthread/">
                    #Pthread</a></span>
            
            <span class="tag"><a href="https://kagaya85.github.io/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/">
                    #并行计算</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://kagaya85.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://kagaya85.github.io/2019/css%E6%B0%94%E6%B3%A1/" class="prev" rel="prev" title="CSS伪类的应用——实现聊天气泡效果"><i class="iconfont icon-left"></i>&nbsp;CSS伪类的应用——实现聊天气泡效果</a>
         
        
        <a href="https://kagaya85.github.io/2019/lock/" class="next" rel="next" title="Unix系统分析——锁">Unix系统分析——锁&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">1997 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://kagaya85.github.io/">Kagaya</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
